#include <main.h>



int32 lecture(void);
int32 dist(void);
//int32 limite = 10;
//#INT_RDA
/*
void RDA_isr(void){
limite = lecture();
}
*/
void main(){
   output_high(PIN_B0);
   output_high(PIN_B1);
   //#define toint(c) ((c & 0x5F) > '9' ? c - '7' : c - '0') //conversion d'un char en int (0,9)
   setup_timer_0(RTCC_INTERNAL); // 409us (us = microseconde) overflow
   setup_timer_1(T1_INTERNAL); //13,1 ms overflow
   enable_interrupts(GLOBAL);
   setup_low_volt_detect(FALSE);
   enable_interrupts(INT_RDA);
   enable_interrupts(GLOBAL);
   delay_ms(100); //délai initialisation
   output_low(PIN_B0);
   output_low(PIN_B1);
   int32 distance=0;
   while(true){
      distance = dist(); //calcul de la distance
      
      /*
      if(distance<limite){ //si la distance est assez grande
         output_low(PIN_B0); //si la sortie est basse led rouge
         output_high(PIN_B1); //si la sortie est haute led verte
      }else{
         output_low(PIN_B1); //vérifie que la led verte est bien éteinte
         output_toggle(PIN_B0); //la led rouge clignote
      }
      */
      if(distance < 100){
         output_low(PIN_E0);
         int test = 35;
         
         char* hexadecimal;
         hexadecimal = (char)test;
         
         int decimal = 0;
         int length = 2;
         /*
         if(test < 0x10){
            length = 1;
         }
         if(test > 0x10){
            length = 2;
         }
         if(test >= 0xFF){
            length = 3;
         }
         */
         
         for(int i = 0; i < length; i++){ //2
         
            char digit = hexadecimal[length -1 -i];
            output_d(digit);
            delay_ms(1000);
               
            if(digit >= '0' && digit <= '9'){
               int exposant = 0;
               if(i == 1){
                  exposant = 16;
               }
               output_d(decimal);
               delay_ms(500);
               
               decimal += (digit - '0') * exposant;
               output_d(decimal);
               delay_ms(500);
            }else{
               int exposant = 0;
               if(i == 1){
                  exposant = 16;
               }
               decimal += (digit - 'A' + 10) * exposant;
               output_d(decimal);
               delay_ms(500);
            }  
         }
         output_d(decimal);
         delay_ms(500);
         
         
         
         /*
         while(test%10 != 0){
            output_d((test));
            test --;
            if(32%10 == 0){ output_d(0x99); }
            
            delay_ms(400);
         }
         */
         //output_d((hexadecimal));
      }else{
         output_high(PIN_E0);
         output_d(distance/10);
      }
      
      
    //printf("%lu\r\n",distance); //envoi du chiffre par le port Comm
      delay_ms(300);
   }
}
/*
int32 lecture(){
   char entre[5]; //buffer de cinq caractères
   int32 sorti=0;
   int i=0,x=0,y=1; //sorti=int voulu
   gets(entre); //attend une chaîne de caractères finie par CR carriage return
   for(x=0;x<5;x++){ //boucle lisant le buffer
      if(entre[x]=='\r'){break;} //quand le char == \r => fin du int
   }
   for(i=x-1;i>0;i--){ //boucle traduisant les char en un int
      sorti+=toint(entre[i])*y; //la variable sorti est incrémentée du int* dizaine /centaine
      y*=10;
   }
   sorti+=toint(entre[0])*y; //la boucle ne veut pas se finir à zéro alors voilà :'(
   return sorti;
   }
   */
int32 dist(){
   float time=0;
   int32 distance=0;
   output_high(pin_b7); //début de l’impulsion sur le trigger de la sonde à ultrasons
   //delay_us(20);
   delay_ms(10);
   output_low(pin_b7); //fin de l’impulsion
   while(!input(PIN_b3)); //tant que la pin b3/canrx du PIC est à low => reliée au echo de la sonde
      set_timer1(0); //mise à zéro du timer 1
   while(input(PIN_b3)); //tant que la pin b3/canrx du PIC est à high
      time=get_timer1(); //récupération du timer
   distance = time*0.00344; //calcul de la distance
   return distance;
   }
